package com.kryptnostic.crypto;

import org.apache.commons.lang3.tuple.Pair;

import cern.colt.bitvector.BitVector;

import com.google.common.base.Charsets;
import com.google.common.hash.HashFunction;
import com.google.common.hash.Hashing;
import com.kryptnostic.bitwise.BitVectors;
import com.kryptnostic.linear.EnhancedBitMatrix;
import com.kryptnostic.linear.EnhancedBitMatrix.SingularMatrixException;
import com.kryptnostic.multivariate.gf2.SimplePolynomialFunction;
import com.kryptnostic.multivariate.polynomial.OptimizedPolynomialFunctionGF2;
import com.kryptnostic.multivariate.polynomial.ParameterizedPolynomialFunctionGF2;

public class EncryptedSearchPrivateKey {
    private static final HashFunction      hf       = Hashing.murmur3_128();
    private static final int               hashBits = hf.bits();

    /*
     * Index collapsers are used for computing the actual index location of a shared document.
     */

    private final EnhancedBitMatrix        hashCollapser, leftSquaringMatrix,rightSquaringMatrix;
    private final PublicKey                publicKey;

    public EncryptedSearchPrivateKey( PrivateKey privateKey, PublicKey publicKey ) throws SingularMatrixException {
        final int NUMBER_OF_TRIES = 1000000;
        int doubleHashBits = hashBits << 1;
        if ( publicKey.getEncrypter().getInputLength() == doubleHashBits ) {
            hashCollapser = EnhancedBitMatrix.identity( doubleHashBits );
        } else {
            hashCollapser = EnhancedBitMatrix.randomRightInvertibleMatrix( hashBits >>> 1, hashBits, NUMBER_OF_TRIES );
        }
        this.leftSquaringMatrix = EnhancedBitMatrix.randomInvertibleMatrix( 8 );
        this.rightSquaringMatrix = EnhancedBitMatrix.randomInvertibleMatrix( 8 );
        this.publicKey = publicKey;
    }

    /**
     * Generates a search token by computing the hash of the provided term and encrypting its hash.
     * 
     * @param term
     * @return A bitvector search token generated by encrypted the hash of the search term.
     * @throws SingularMatrixException
     */
    public BitVector prepareSearchToken( String term ) throws SingularMatrixException {
        BitVector searchHash = hash( term );
        return publicKey.getEncrypter().apply(
                BitVectors.concatenate( searchHash, BitVectors.randomVector( searchHash.size() ) ) );
    }

    public BitVector hash( String term ) {
        return hashCollapser
                .multiply( BitVectors.fromBytes( hashBits, hf.hashString( term, Charsets.UTF_8 ).asBytes() ) );
    }

    public EnhancedBitMatrix getLeftSquaringMatrix() {
        return leftSquaringMatrix;
    }
    
    public EnhancedBitMatrix getRightSquaringMatrix() {
        return rightSquaringMatrix;
    }

    public EnhancedBitMatrix newDocumentKey() {
        return EnhancedBitMatrix.randomInvertibleMatrix( 8 );
    }

    public Pair<SimplePolynomialFunction, SimplePolynomialFunction> getQueryHasherPair(
            SimplePolynomialFunction globalHash,
            PrivateKey privateKey ) throws SingularMatrixException {
        SimplePolynomialFunction hashOfDecryptor = globalHash.compose( privateKey.getMirroredDecryptor() );
        return Pair.of(
                rightMultiply( hashOfDecryptor, leftSquaringMatrix ),
                leftMultiply( hashOfDecryptor, rightSquaringMatrix ) );
    }

    public static SimplePolynomialFunction rightMultiply( SimplePolynomialFunction f, EnhancedBitMatrix rhs ) {
        BitVector[] contributions = f.getContributions();
        BitVector[] newContributions = new BitVector[ contributions.length ];

        for ( int i = 0; i < contributions.length; ++i ) {
            newContributions[ i ] = BitVectors.fromSquareMatrix( EnhancedBitMatrix.squareMatrixfromBitVector(
                    contributions[ i ] ).multiply( rhs ) );
        }

        if ( f.getClass().equals( ParameterizedPolynomialFunctionGF2.class ) ) {
            ParameterizedPolynomialFunctionGF2 g = (ParameterizedPolynomialFunctionGF2) f;
            return new ParameterizedPolynomialFunctionGF2(
                    g.getInputLength(),
                    newContributions[ 0 ].size(),
                    g.getMonomials(),
                    newContributions,
                    g.getPipelines() );
        } else {
            return new OptimizedPolynomialFunctionGF2(
                    f.getInputLength(),
                    newContributions[ 0 ].size(),
                    f.getMonomials(),
                    newContributions );
        }
    }

    public static SimplePolynomialFunction leftMultiply( SimplePolynomialFunction f, EnhancedBitMatrix lhs ) {
        BitVector[] contributions = f.getContributions();
        BitVector[] newContributions = new BitVector[ contributions.length ];

        for ( int i = 0; i < contributions.length; ++i ) {
            newContributions[ i ] = BitVectors.fromSquareMatrix( lhs.multiply( EnhancedBitMatrix
                    .squareMatrixfromBitVector( contributions[ i ] ) ) );
        }

        if ( f.getClass().equals( ParameterizedPolynomialFunctionGF2.class ) ) {
            ParameterizedPolynomialFunctionGF2 g = (ParameterizedPolynomialFunctionGF2) f;
            return new ParameterizedPolynomialFunctionGF2(
                    g.getInputLength(),
                    newContributions[ 0 ].size(),
                    g.getMonomials(),
                    newContributions,
                    g.getPipelines() );
        } else {
            return new OptimizedPolynomialFunctionGF2(
                    f.getInputLength(),
                    newContributions[ 0 ].size(),
                    f.getMonomials(),
                    newContributions );
        }
    }

    public static SimplePolynomialFunction twoSidedMultiply(
            SimplePolynomialFunction f,
            EnhancedBitMatrix lhs,
            EnhancedBitMatrix rhs ) {
        BitVector[] contributions = f.getContributions();
        BitVector[] newContributions = new BitVector[ contributions.length ];

        for ( int i = 0; i < contributions.length; ++i ) {
            newContributions[ i ] = BitVectors.fromSquareMatrix( lhs.multiply(
                    EnhancedBitMatrix.squareMatrixfromBitVector( contributions[ i ] ) ).multiply( rhs ) );
        }

        if ( f.getClass().equals( ParameterizedPolynomialFunctionGF2.class ) ) {
            ParameterizedPolynomialFunctionGF2 g = (ParameterizedPolynomialFunctionGF2) f;
            return new ParameterizedPolynomialFunctionGF2(
                    g.getInputLength(),
                    newContributions[ 0 ].size(),
                    g.getMonomials(),
                    newContributions,
                    g.getPipelines() );
        } else {
            return new OptimizedPolynomialFunctionGF2(
                    f.getInputLength(),
                    newContributions[ 0 ].size(),
                    f.getMonomials(),
                    newContributions );
        }
    }

    public static int getHashBits() {
        return hashBits;
    }
}
